import * as vs from 'vscode';
import * as fs from 'fs';

export class TwoDecorations {
	private readonly decorationType = vs.window.createTextEditorDecorationType({
		rangeBehavior: vs.DecorationRangeBehavior.OpenOpen,
		// opacity: "0.8",
		backgroundColor: "#333"
	});

	constructor(context: vs.ExtensionContext) {
		context.subscriptions.push(vs.commands.registerCommand("vscode-testing.toggleGenerated", this.toggleGenerated, this));
		context.subscriptions.push(vs.workspace.registerTextDocumentContentProvider("dart-gen", new DartGenProvider()));
	}

	private async toggleGenerated(): Promise<void> {
		const existingEditor = vs.window.activeTextEditor;
		const existingDoc = existingEditor?.document;
		if (!existingEditor || !existingDoc)
			return;

		const firstVisibleRange = existingEditor.visibleRanges[0];
		await vs.commands.executeCommand("workbench.action.closeActiveEditor");
		const newDoc = existingDoc.uri.scheme === 'dart-gen'
			? await vs.workspace.openTextDocument(existingDoc.uri.with({ scheme: 'file' }))
			: existingDoc.uri.scheme === 'file'
				? await vs.workspace.openTextDocument(existingDoc.uri.with({ scheme: 'dart-gen' }))
				: undefined;

		if (!newDoc)
			return;

		const newEditor = await vs.window.showTextDocument(newDoc, existingEditor.viewColumn);
		newEditor.revealRange(firstVisibleRange);

		const decorations: vs.DecorationOptions[] = [];

		const text = newDoc.getText();
		const generatedCode = new RegExp("Map<String, Object\\?> toJson\\(\\) {.*?}", "gs");
		let result: RegExpExecArray | null;
		while ((result = generatedCode.exec(text)) !== null) {
			decorations.push({
				range: new vs.Range(
					newDoc.lineAt(newDoc.positionAt(result.index).line).range.start,
					newDoc.positionAt(result.index + result[0].length),
				),
				hoverMessage: "This code was generated by ...",
			});
		}
		newEditor.setDecorations(this.decorationType, decorations);
	}
}


class DartGenProvider implements vs.TextDocumentContentProvider {
	provideTextDocumentContent(uri: vs.Uri, token: vs.CancellationToken): vs.ProviderResult<string> {
		const filePath = uri.with({ scheme: 'file' }).fsPath;
		const content = fs.readFileSync(filePath).toString();

		const jsonClasses = new RegExp("@json\\nclass \\w+ {\\n(?:  .*)*\\n}", "g");
		const generatedContent = content.replace(jsonClasses, (matched, b, c) => {
			return matched.substring(0, matched.length - 1) + "\n  Map<String, Object?> toJson() {\n    // Generated code...\n  }\n}";
		});

		return generatedContent;
	}
}
